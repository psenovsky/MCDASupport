% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/electre1s.R
\name{electre1s}
\alias{electre1s}
\title{electre1s : ELECTRE 1S method used to solve multiple criteria decision
 making (experimental)}
\description{
Method for supporting multicriteria decision making used to identify so
 called kernel of solution as set of alternatives which are not dominated
 by any other alternative. Dominated alternatives can be ommited from
 decision making as they clearly represent sub-optimal solution for the
 problem.

Method does not provide ranking of the alternatives.

Computationally the method can be seen as a hybrid of ELECTRE III
 (\code{\link{Electre_3}}) and I \code{\link{electre1}} methods. From
 ELECTRE III it takes concordance matrix computation as it works with fuzzy
 defined preference (P), indifference (Q) and veto (V) thresholds. From
 ELECTRE I it takes procedure to identify kernel of the solution.

The procedure itself is as follows. First we compute Concordance matrix.
 Concordancce matrix (index) measures strength of the statement that
 alternative a outranks alternative b.

To compute concordance matrix, partial concordance matrix \mjseqn{c_j}
 of the criteria needs to be computed first. The partial concordance matrix
 considers concordance by comparing performances of the alternatives in
 criterium \mjseqn{j}.

\mjsdeqn{c_j(a,b) = \left\lbrace\begin{array}{ll} 1 & \;if\; PM_j(a) + Q_j(a) \ge PM_j(b) \cr 0 & \;if\; PM_j(a) + P_j(a) < PM_j(b)) \cr \frac{PM_j(a) - PM_j(b) + P_j(a)}{P_j(a) - Q_j(a)} & else\end{array}\right.}

Since the procedure is same as for ELECTRE III, the code has been refactored
 into separate function \code{\link{ELECTRE_ConcordanceMatrix}} and only
 called form this function.

Based on partial concordance matrixes we compute concordence matrix
 \mjseqn{C} as:

\mjsdeqn{C(a,b) = \frac{\sum (w_j \cdot c_j(a,b))}{\sum w_j}}

where

PM ... performance of alternative in criterion, Q ... indifference
 threshold, P ... prefference threshold, w ... weights.

Discordance matrix \mjseqn{d} consist of discordance indexes which provide
 together with discordance threshold (exceeding this threshold) information
 preventing outranking.

\mjsdeqn{d[i,j] = \left\lbrace\begin{array}{ll} 1 & \;if\; PM[j,k] - PM[i,k] \ge V_k - Q_k \cdot \frac{1 - C[i,j] - (w_k/\sum w)}{1 - \lambda - (w_k/\sum w)}  \cr 0 & otherwise \end{array}\right.}

Where d ... discordance matrix, i ... variable used to iterate over
 alternatives, j,k ... variables use to iterate over criteria,
 \mjseqn{\lambda} ... cutoff criterium, V ... veto threshold, othervise
 same notation as in previous equations has been used.

Next credibility matrix needs to be computed. Credibility matrix takes into
 account concordance and discordance indexes to evaluate haw credible it is
 that a over prerforms b (aSb).

\mjsdeqn{cred(a,b) = \left\lbrace\begin{array}{ll} 1 & \;if\; C(a,b) \ge \lambda \; and \; d(a,b) = 0 \cr 0 & otherwise \end{array}\right.}

Finally kernel of solution is computed in same manner as for ELECTRE I
 method using \code{\link{ELECTRE1_Kernel}}. We use credibility matrix as
 input parameter for the function as it is also adjacancy matrix. The
 matrix needs to be simplified by removing loops from it using for example
 Johnson's algorithm.

The kernel is returned in form of graph, vectors of dominated alternatives
 and vector of alternatives forming kernel.
}
\examples{

## ------------------------------------------------
## Method `electre1s$new`
## ------------------------------------------------

PM <- cbind(
  c(-14,129,-10,44,-14),
  c(90,100,50,90,100),
  c(0,0,0,0,0),
  c(40,0,10,5,20),
  c(100,0,100,20,40)
)
rownames(PM) <- c("Project1","Project2","Project3","Project4","Project5")
colnames(PM) <- c( "CR1","CR2","CR3","CR4","CR5")
minmaxcriteria <- 'max'
Q <- c(25,16,0,12,10) #Indifference thresholds
P <- c(50,24,1,24,20) #Preference thresholds
V <- c(100,60,2,48,90) #Veto thresholds
w <- c(1,1,1,1,1) #weights
e1s <- electre1s:new(PM, w, Q, P, V)

## ------------------------------------------------
## Method `electre1s$sensitivity`
## ------------------------------------------------

PM <- cbind(
 c(-14,129,-10,44,-14),
 c(90,100,50,90,100),
 c(0,0,0,0,0),
 c(40,0,10,5,20),
 c(100,0,100,20,40)
)
rownames(PM) <- c("Project1","Project2","Project3","Project4","Project5")
colnames(PM) <- c( "CR1","CR2","CR3","CR4","CR5")
minmaxcriteria <- 'max'
Q <- c(25,16,0,12,10) #Indifference thresholds
P <- c(50,24,1,24,20) #Preference thresholds
V <- c(100,60,2,48,90) #Veto thresholds
w <- c(1,1,1,1,1) #weights
t <- electre1s$new(PM, w, Q, P, V, minmaxcriteria)
t$sensitivity(step = 1)
}
\references{
Balamurali, M.: pyDecisions - A Python Library of management decision making
 techniques. Available on-line from
 \url{https://github.com/Valdecy/pyDecisions}

Rogers, Martin and Myastre, Lucien-Yves. ELECTRE and Decision Support:
 Methods and Applications in Engineering and Infrastructure investment.
 Springer 2000, 208 p., ISBN 978-1-4757-5057-7

Prombo, M. Package OutrankingTools, CRAN: 2015, available from:
 \url{https://cran.r-project.org/web/packages/OutrankingTools/}

Rogers, Martin and Myastre, Lucien-Yves. ELECTRE and Decision Support:
 Methods and Applications in Engineering and Infrastructure investment.
 Springer 2000, 208 p., ISBN 978-1-4757-5057-7
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{1S}
\keyword{ELECTRE}
\keyword{I}
\keyword{III}
\keyword{concordance}
\keyword{credibility}
\keyword{discordane}
\keyword{kernel}
\keyword{matrix}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm_orig}}{original (unmodified) performace matrix}

\item{\code{pm}}{transformed performance matrix, all criteria will be maximized}

\item{\code{w}}{weights vector}

\item{\code{q}}{vector of indifference thresholds}

\item{\code{p}}{vector of preference thresholds}

\item{\code{v}}{vector of veto thresholds}

\item{\code{minmaxcriteria}}{criteriaMinMax Vector containing the preference
direction on each of the criteria. "min" (resp."max") indicates that
the criterion has to be minimized (maximized).}

\item{\code{lambda}}{lambda parameter defining concordance threshold.
The default value is 0.5, but the value can be in interval <0.5;1>.}

\item{\code{ConcordanceMatrix}}{concordance matrix}

\item{\code{DiscordanceIndex}}{discordance index (list of discordance matrices
separate for each criterium)}

\item{\code{CredibilityIndex}}{credibility index (list seprate for each
criterium)}

\item{\code{Kernel}}{kernel of the solution}

\item{\code{Dominated}}{vector of alternatives identified as dominated}

\item{\code{graph}}{netvork graph visualizing alternative overranking}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-electre1s-new}{\code{electre1s$new()}}
\item \href{#method-electre1s-compute}{\code{electre1s$compute()}}
\item \href{#method-electre1s-summary}{\code{electre1s$summary()}}
\item \href{#method-electre1s-sensitivity}{\code{electre1s$sensitivity()}}
\item \href{#method-electre1s-clone}{\code{electre1s$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-electre1s-new"></a>}}
\if{latex}{\out{\hypertarget{method-electre1s-new}{}}}
\subsection{Method \code{new()}}{
public constructor, creates electre1s object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{electre1s$new(
  pm,
  w,
  q,
  p,
  v,
  minmaxcriteria = "max",
  lambda = 0.5,
  test = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{Performance matrix}

\item{\code{w}}{weight vector}

\item{\code{q}}{vector of indifference thresholds}

\item{\code{p}}{vector of preference thresholds}

\item{\code{v}}{vector of veto thresholds}

\item{\code{minmaxcriteria}}{vector of direction of each of the criteria. "min"
(resp."max")indicates that the criterion has to be minimized
(maximized). Vector canbe replaced by single max or min value if all
criteria are maximized or minimized.}

\item{\code{lambda}}{lambda parameter defining concordance threshold. The
default value is 0.5, but the value can be in interval <0.5;1>.}

\item{\code{test}}{Boolean value specifying whether the consistency tests in
the constructor should be used. FALSE value is usually used during
sensitivity testing.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{PM <- cbind(
  c(-14,129,-10,44,-14),
  c(90,100,50,90,100),
  c(0,0,0,0,0),
  c(40,0,10,5,20),
  c(100,0,100,20,40)
)
rownames(PM) <- c("Project1","Project2","Project3","Project4","Project5")
colnames(PM) <- c( "CR1","CR2","CR3","CR4","CR5")
minmaxcriteria <- 'max'
Q <- c(25,16,0,12,10) #Indifference thresholds
P <- c(50,24,1,24,20) #Preference thresholds
V <- c(100,60,2,48,90) #Veto thresholds
w <- c(1,1,1,1,1) #weights
e1s <- electre1s:new(PM, w, Q, P, V)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-electre1s-compute"></a>}}
\if{latex}{\out{\hypertarget{method-electre1s-compute}{}}}
\subsection{Method \code{compute()}}{
computes the ELECTRE IS problem. Usually doesn't need to be run manually
 as it is called by class constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{electre1s$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-electre1s-summary"></a>}}
\if{latex}{\out{\hypertarget{method-electre1s-summary}{}}}
\subsection{Method \code{summary()}}{
summary of the ELECTRE IS resutls.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{electre1s$summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
basic information on the model and its kernel. Will also list
 dominated alternatives, if such were identified.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-electre1s-sensitivity"></a>}}
\if{latex}{\out{\hypertarget{method-electre1s-sensitivity}{}}}
\subsection{Method \code{sensitivity()}}{

\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{electre1s$sensitivity(step = 0.01)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{iteration step the function uses to generate the testing
interval}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns dataframe specifyin upper and lower limits of the solution's
 sensitivity the thresholds. Limits values can be replaced by
 insens. if no limit has been identified.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{PM <- cbind(
 c(-14,129,-10,44,-14),
 c(90,100,50,90,100),
 c(0,0,0,0,0),
 c(40,0,10,5,20),
 c(100,0,100,20,40)
)
rownames(PM) <- c("Project1","Project2","Project3","Project4","Project5")
colnames(PM) <- c( "CR1","CR2","CR3","CR4","CR5")
minmaxcriteria <- 'max'
Q <- c(25,16,0,12,10) #Indifference thresholds
P <- c(50,24,1,24,20) #Preference thresholds
V <- c(100,60,2,48,90) #Veto thresholds
w <- c(1,1,1,1,1) #weights
t <- electre1s$new(PM, w, Q, P, V, minmaxcriteria)
t$sensitivity(step = 1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-electre1s-clone"></a>}}
\if{latex}{\out{\hypertarget{method-electre1s-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{electre1s$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
