% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cradis.R
\name{cradis}
\alias{cradis}
\title{compromise ranking of alternatives from distance to ideal solution}
\description{
Approach to ranking problem integrating parts of \link{aras}, \link{marcos}
 and \link{topsis} methods.

Similarly to ARAS method it starts with decision problem formulation using
 performance metrix with n criteria in columns and m alternatives in rows
 (step 1). In step 2) The performance in criteria is then normalized using:

\mjsdeqn{r_{ij} = \frac{x_{ij}}{x_{max_j}}}

for benefit criteria and for cost criteria

\mjsdeqn{r_{ij} = \frac{x_{min_j}}{x_{ij}}}

In step 3) the weights are applied on normalized matrix.

\mjsdeqn{v_{ij} = w_{j} r_{ij}}

In step 4) determining ideal and antiideal solution of the problem as
 miximal (ideal) and minimal (anti-ideal) values of criteria.

\mjsdeqn{t_{i} = max(v_{ij})}

\mjsdeqn{t_{ai} = min(v_{ij})}

In step 5) deviations from these is computed as difference between the
 normalized weighted value and the ideal or antiideal solution:

\mjsdeqn{d^+ = t_i - v_{ij}}

\mjsdeqn{d^- = v_{ij} - t_ai}

Then the grades s are computed by summing up these differences (step 6).

\mjsdeqn{s_i^+ = \sum_{j=1}^n d^+}

\mjsdeqn{s_i^- = \sum_{j=1}^n d^-}

Then the utility function is constructed as a ratio between the optimum and
 actual value (step 7).

\mjsdeqn{K_i^+ = \frac{s_0^+}{s_i^+}}

\mjsdeqn{K_i^- = \frac{s_i^-}{s_0^-}}

Finaly (step 8) the ranking of the alternatives ise derived from the average
 of utility functions.

\mjsdeqn{Q_i = \frac{K_i^+ + K_i^-}{2}}

First 4 steps of the method are closely mimicking ARAS approach, remainder
 is philosophically closer to MARCOS or TOPSIS methods. Mathematically the
 approach to the problem is closer to MARCOS.
}
\examples{

## ------------------------------------------------
## Method `cradis$new`
## ------------------------------------------------

PM <- rbind(
   c(0.446, 1.785, 6.643, 6.843, 50),
   c(1.113, 2.425, 10.525, 2.902, 250),
   c(1.246, 3.321, 14.224, 3.885, 600),
   c(1.935, 3.678, 17.852, 4.406, 1000),
   c(0.446, 3.062, 5.238, 3.112, 200),
   c(1.064, 3.814, 14.558, 4.121, 250),
   c(1.654, 4.581, 17.888, 4.886, 1600),
   c(1.924, 5.226, 22.224, 5.702, 1500),
   c(0.337, 4.444, 24.708, 4.123, 450),
   c(0.998, 5.12, 18.012, 5.206, 1500),
   c(1.622, 5.886, 22.226, 6.226, 600),
   c(1.844, 6.234, 26.128, 6.786, 1500),
   c(0.531, 5.6, 18.883, 5.405, 800),
   c(1.023, 6.123, 21.987, 6.501, 1500),
   c(1.664, 7.244, 27.012, 7.421, 1600),
   c(2.012, 7.345, 28.021, 7.923, 1000)
)
rownames(PM) <- c("A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9",
   "A10", "A11", "A12", "A13", "A14", "A15", "A16")
colnames(PM) <- c("Ra", "Ax", "Ay", "Az", "Q")
w <- rep(0.2, times = 5) #equal weights
minmax <- c("min", "min", "min", "min", "max")
t <- cradis$new(PM, w, minmax)
}
\references{
Puška, A., Stević, Ž., Panučar, D.: Evaluation and selection of healtcare
 waste incinerators using extended sustainability criteria and multicriteria
 analysis methods. Environment, Development and Sustainability, vol. 24, pp.
 11195-11225 (2022), DOI: 10.1007/s10668-021-01902-2
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{ARAS}
\keyword{CRADIS}
\keyword{MARCOS}
\keyword{TOPSIS}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm_orig}}{original state of the performance matrix (before
transforming criteria)}

\item{\code{pm}}{transformed performance matrix, all criteria are maximized}

\item{\code{w}}{weight vector}

\item{\code{minmax}}{directio of optimization, can be replaced by single min
or max if all criteria have same optimization direction.}

\item{\code{q}}{sorted average utility order descending from best to worst}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-cradis-new}{\code{cradis$new()}}
\item \href{#method-cradis-compute}{\code{cradis$compute()}}
\item \href{#method-cradis-summary}{\code{cradis$summary()}}
\item \href{#method-cradis-clone}{\code{cradis$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cradis-new"></a>}}
\if{latex}{\out{\hypertarget{method-cradis-new}{}}}
\subsection{Method \code{new()}}{
public constructor of the function. Validates inputs and computes the
 model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{cradis$new(pm, w, minmax = "max")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{performance matrix (alternatives in rows and criteria in
columns)}

\item{\code{w}}{weights vector}

\item{\code{minmax}}{vector of optimization direction (min/max, max is default)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
inicialized and computed model
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{PM <- rbind(
   c(0.446, 1.785, 6.643, 6.843, 50),
   c(1.113, 2.425, 10.525, 2.902, 250),
   c(1.246, 3.321, 14.224, 3.885, 600),
   c(1.935, 3.678, 17.852, 4.406, 1000),
   c(0.446, 3.062, 5.238, 3.112, 200),
   c(1.064, 3.814, 14.558, 4.121, 250),
   c(1.654, 4.581, 17.888, 4.886, 1600),
   c(1.924, 5.226, 22.224, 5.702, 1500),
   c(0.337, 4.444, 24.708, 4.123, 450),
   c(0.998, 5.12, 18.012, 5.206, 1500),
   c(1.622, 5.886, 22.226, 6.226, 600),
   c(1.844, 6.234, 26.128, 6.786, 1500),
   c(0.531, 5.6, 18.883, 5.405, 800),
   c(1.023, 6.123, 21.987, 6.501, 1500),
   c(1.664, 7.244, 27.012, 7.421, 1600),
   c(2.012, 7.345, 28.021, 7.923, 1000)
)
rownames(PM) <- c("A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9",
   "A10", "A11", "A12", "A13", "A14", "A15", "A16")
colnames(PM) <- c("Ra", "Ax", "Ay", "Az", "Q")
w <- rep(0.2, times = 5) #equal weights
minmax <- c("min", "min", "min", "min", "max")
t <- cradis$new(PM, w, minmax)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cradis-compute"></a>}}
\if{latex}{\out{\hypertarget{method-cradis-compute}{}}}
\subsection{Method \code{compute()}}{
computes the model bas of class properties. Usually we do not run the
 computation manually (it is run from class' constructor).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{cradis$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cradis-summary"></a>}}
\if{latex}{\out{\hypertarget{method-cradis-summary}{}}}
\subsection{Method \code{summary()}}{
summary of the CRADIS method resutls.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{cradis$summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
basic information on the model including ranking.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cradis-clone"></a>}}
\if{latex}{\out{\hypertarget{method-cradis-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{cradis$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
