% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evamix.R
\name{evamix}
\alias{evamix}
\title{EVAluation of MIXed data method}
\description{
Method has been developed in 1982 by Voogd. It is intended to help with
 evaluation of mixed ordinal (O) and numeric - cardinal (C) criteria. The
 methods evaluates ordinal and cardinal criteria separately and then
 integrates the results to derive final ranking.

There are some limitations for the method. It is compensatory method and it
 presumes that the criteria are independent.

We start by formulating performance matrix of alternatives (rows) in
 criteria (columns). Criteria weights need to be provided for computation
 purposes. Original EVAMIX method proposes two approaches for weight
 derivation, but implementation of EVAMIX does NOT support these, so the
 weights are required as a input for the method.

In first step we divide original performance matrix into two subsets only
 consisting of ordinal or cardinal criteria. We compute supperiority rate of
 the alternatives. For ordinal criteria:

\mjsdeqn{\alpha_{ii'} = [ \sum_{j \in O} (w_j \cdot sgn(e_{ij} - e_{i'j}))^{\gamma}]^{1/\gamma}}

where \mjseqn{e_{ij}} indicates evaluation of alternative Ai based on
criterium \mjseqn{c_j} against \mjseqn{e_{i'j}} which evaluates alternative
Ai', \mjseqn{w_j} is weight of the criterium j and \mjseqn{\gamma} is
arbitrary scaling parameter. Any positive number will work for it, but is
 set to 1 by default.

In ordinal scales no true distance between the points on this scale are
 exactly known. Sgn (signum) part of the equation evaluates only if the
 alternative Ai is better then Ai' in that criterium with +1 for yes, 0
 for are equal and -1 for Ai' performs better then Ai.

Cardinal criteria are evaluated using true difference between alternatives
Ai and Ai':

\mjsdeqn{a_{ii'} = [ \sum_{j \in C} (w_j \cdot (e_{ij} - e_{i'j}))^{\gamma}]^{1/\gamma}}

Since the results for cardinal and ordinal superiority retes are computed
 in differnt scale, they need to be normalized first using min-max method
 before the total dominance is computed:

\mjsdeqn{D_{ii'} = w_O \delta_{ii'} + w_C d_{ii'}}

where \mjseqn{w_O = \sum_{j \in O} w_j} and
 \mjseqn{w_C = \sum_{j \in C} w_j}.

Finally evaluation score of the alternatives is calculated. When ordered
 from max to min it provides ranking of the alternatives.

\mjsdeqn{S_i = [\sum_{i'} \frac{D_{i'i}}{D_{ii'}}]^{-1}}
}
\examples{

## ------------------------------------------------
## Method `evamix$new`
## ------------------------------------------------

alternatives <- c("A1", "A2", "A3")
criteria <- c("C1", "C2", "C3", "C4", "C5", "C6")
pm <- rbind(
  c(30, 2, 4, 24, 4, 12.5),
  c(12, 3, 2, 25, 2, 22),
  c(15, 4, 1, 32, 1, 10)
)
rownames(pm) <- alternatives
colnames(pm) <- criteria
minmax <- c("min", "max", "max", "max", "min", "max")
crit_type <- c("C", "O", "O", "C", "O", "C")
w <-c(0.1, 0.175, 0.25, 0.15, 0.125, 0.2)
gamma <- 1
t <- evamix$new(pm, minmax, w, crit_type, gamma)
}
\references{
Alinezhad, A., Khalili, J. New Methods and Applications in Multiple
 Attribute Decision Making (MADM). Springer Nature Switzerland AG, 2019,
 233 p., ISBN 978-3-030-15009-9
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{QUALIFLEX}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm}}{performance matrix. Criteria (in columns) are expected to be
ordered from most influential to least influential.}

\item{\code{minmax}}{optimization direction vector for criteria. Either min or
max. Can be substituted by single min or max if optimization direction
is same for all criteria. The value needs to be provided for all
numeric criteria (ordinal criteria are already considered processed).}

\item{\code{w}}{weight of the criteria}

\item{\code{crit_type}}{vector of criteria types (O or C)}

\item{\code{gamma}}{scaling factor, positive number, 1 by default}

\item{\code{finalRank}}{final ranking of the alternatives}

\item{\code{evaluation_score}}{Evaluation score of the alternative}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-evamix-new}{\code{evamix$new()}}
\item \href{#method-evamix-compute}{\code{evamix$compute()}}
\item \href{#method-evamix-summary}{\code{evamix$summary()}}
\item \href{#method-evamix-clone}{\code{evamix$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-evamix-new"></a>}}
\if{latex}{\out{\hypertarget{method-evamix-new}{}}}
\subsection{Method \code{new()}}{
class constructor, validates data and computes the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{evamix$new(pm, minmax = "max", w, crit_type, gamma = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{performance matrix. Criteria in columns, ordered from most to
least influential}

\item{\code{minmax}}{optimization direction vector for criteria. Either min or
max. Can be substituted by single min or max if optimization direction
is same for all criteria. The value needs to be provided for all
numeric criteria (ordinal criteria are already considered processed).}

\item{\code{w}}{weight of the criteria}

\item{\code{crit_type}}{vector of criteria types (O or C)}

\item{\code{gamma}}{scaling factor, positive number, 1 by default}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
instance of the class including computed model
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{alternatives <- c("A1", "A2", "A3")
criteria <- c("C1", "C2", "C3", "C4", "C5", "C6")
pm <- rbind(
  c(30, 2, 4, 24, 4, 12.5),
  c(12, 3, 2, 25, 2, 22),
  c(15, 4, 1, 32, 1, 10)
)
rownames(pm) <- alternatives
colnames(pm) <- criteria
minmax <- c("min", "max", "max", "max", "min", "max")
crit_type <- c("C", "O", "O", "C", "O", "C")
w <-c(0.1, 0.175, 0.25, 0.15, 0.125, 0.2)
gamma <- 1
t <- evamix$new(pm, minmax, w, crit_type, gamma)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-evamix-compute"></a>}}
\if{latex}{\out{\hypertarget{method-evamix-compute}{}}}
\subsection{Method \code{compute()}}{
computes ORESTE model based on parameters of the fields of the class.
 Usually run automatically as part of class inititation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{evamix$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-evamix-summary"></a>}}
\if{latex}{\out{\hypertarget{method-evamix-summary}{}}}
\subsection{Method \code{summary()}}{
prepares summary of the EVAMIX method resutls and outputs them
 to the console.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{evamix$summary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-evamix-clone"></a>}}
\if{latex}{\out{\hypertarget{method-evamix-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{evamix$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
