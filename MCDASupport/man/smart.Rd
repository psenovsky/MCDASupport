% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smart.R
\name{smart}
\alias{smart}
\title{Simple Multi-Attribute Rating Technique}
\description{
Simple approach to evaluate utility of the alternatives characterized by
 mixed criteria (expressed either numerically or using ordinal values).

For ordinal values, the criteria are expected to use following scale:
\itemize{
 \item{poor: 4}
 \item{fairly weak: 5}
 \item{medium: 6}
 \item{fairly good: 7}
 \item{good: 8}
 \item{very good: 9}
 \item{excellent: 10}
}

 Qualitatively expressed criteria use their natural units for its first step.
 We compute:

\mjsdeqn{v = log_2 64 \cdot \frac{P_v - P_{min}}{P_{max} - P_{min}}}

 Where Pv indicates actual value of the attribute in the criterium, Pmax and
 Pmin maximum and minimum on the used scale. Decision maker states these
 values.

We use this information to compute effective weights for positive criteria
 as:

\mjsdeqn{g_{ij} = 4 + v}

 and for negative (cost) criteria:

\mjsdeqn{g_{ij} = 10 - v}

As outcome both ordinal and numeric criteria will be in interval (4; 10).

In next step the criteria weights need to be established. To do that the
 decision maker provides his/her insight into how much do various criteria
 contribute to the outcome of the decision. Information  is provided in form
 of vector of the criteria's ranks $h_j$ using same ordinal scale (4 - 10)
 as before. The weights are normalized using equation:

\mjsdeqn{w_j = \frac{\sqrt{2}^{h_j}}{\sum_{j=1}^n \sqrt{2}^{h_j}}}

Final ranking is derived from measure fi:

\mjsdeqn{f_i = \sum_{j=1}^n w_j \cdot g_{ij}}

Alternative with highest value of fi is considered best. This implementation
 uses \link{wsm} function to compute this final results and provide more
 fancy outputs.
}
\examples{

## ------------------------------------------------
## Method `smart$new`
## ------------------------------------------------

alternatives <- c("A1", "A2", "A3")
criteria <- c("consumer price", "max. speed", "acceleration to 100", "trunk volume")
pm <- rbind(
  c(25000, 153, 15.3, 250),
  c(33000, 177, 12.3, 380),
  c(40000, 199, 11.1, 480)
)
rownames(pm) <- alternatives
colnames(pm) <- criteria
minmax <- c("min", "max", "min", "max")
ordinal <- c(FALSE, FALSE, FALSE, FALSE)
hj <- c(9, 5, 7, 6)
t <- smart(pm, hj, minmax, ordinal)
}
\references{
Alinezhad, A., Khalili, J. New Methods and Applications in Multiple
 Attribute Decision Making (MADM). Springer Nature Switzerland AG, 2019,
 233 p., ISBN 978-3-030-15009-9
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{SMART}
\keyword{WSM}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm}}{performance matrix}

\item{\code{hj}}{rank of the criteria. The decision maker assigns a value on
ordinal scale (4; 10), see general remars of the method, to express how
the criterium contributes to explanation of the decision}

\item{\code{minmax}}{optimization direction vector for criteria. Either min or
max. Can be substituted by single min or max if optimization direction
is same for all criteria. The value needs to be provided for all
numeric criteria (ordinal criteria are already considered processed).}

\item{\code{ordinal}}{vector describing nature of the criteria. Criteria with
TRUE values are considered ordinal and with FALSE values are considered
numeric.}

\item{\code{pmax}}{numeric vector of maximums of the criteria}

\item{\code{pmin}}{numeric vector of minimums of the criteria}

\item{\code{w}}{normalized weights of the criteria derived from hj}

\item{\code{result_table}}{has weighted performance matrix with added columns
to summ performance and extress this sum as a percentage of the best
alternative}

\item{\code{weighted_sum_prc}}{vector specifying how close the alternatives are
to the best aleternative (expresed as the percentage of best) sorted
descending (from best to worst)}

\item{\code{scoreM}}{results of the WSM presented as stacked bar chart. The
graph clearly shows contribution of the criteria to overall performance
of the alternative.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-smart-new}{\code{smart$new()}}
\item \href{#method-smart-compute}{\code{smart$compute()}}
\item \href{#method-smart-summary}{\code{smart$summary()}}
\item \href{#method-smart-clone}{\code{smart$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-smart-new"></a>}}
\if{latex}{\out{\hypertarget{method-smart-new}{}}}
\subsection{Method \code{new()}}{
class constructor, validates data and computes the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{smart$new(pm, hj, minmax = "max", ordinal, pmax, pmin)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{performance matrix}

\item{\code{hj}}{rank of the criteria. The decision maker assigns a value on
ordinal scale (4; 10), see general remars of the method, to express how
the criterium contributes to explanation of the decision}

\item{\code{minmax}}{optimization direction vector for criteria. Either min or
max. Can be substituted by single min or max if optimization direction
is same for all criteria. The value needs to be provided for all
numeric criteria (ordinal criteria are already considered processed).}

\item{\code{ordinal}}{vector describing nature of the criteria. Criteria with
TRUE values are considered ordinal and with FALSE values are considered
numeric.}

\item{\code{pmax}}{numeric vector of maximums of the criteria}

\item{\code{pmin}}{numeric vector of minimums of the criteria}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
instance of the class including computed model
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{alternatives <- c("A1", "A2", "A3")
criteria <- c("consumer price", "max. speed", "acceleration to 100", "trunk volume")
pm <- rbind(
  c(25000, 153, 15.3, 250),
  c(33000, 177, 12.3, 380),
  c(40000, 199, 11.1, 480)
)
rownames(pm) <- alternatives
colnames(pm) <- criteria
minmax <- c("min", "max", "min", "max")
ordinal <- c(FALSE, FALSE, FALSE, FALSE)
hj <- c(9, 5, 7, 6)
t <- smart(pm, hj, minmax, ordinal)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-smart-compute"></a>}}
\if{latex}{\out{\hypertarget{method-smart-compute}{}}}
\subsection{Method \code{compute()}}{
computes SMART model based on parameters of the fields of the class.
 Usually run automatically as part of class inititation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{smart$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-smart-summary"></a>}}
\if{latex}{\out{\hypertarget{method-smart-summary}{}}}
\subsection{Method \code{summary()}}{
prepares summary of the CODAS method resutls and outputs them
 to the console.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{smart$summary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-smart-clone"></a>}}
\if{latex}{\out{\hypertarget{method-smart-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{smart$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
