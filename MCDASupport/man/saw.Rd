% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/saw.R
\name{saw}
\alias{saw}
\title{SAW (Simple Additive Weight) method}
\description{
SAW is a accronym for Simple Additive Weighting method. From
 implementation point of wiew it is basically \link{wsm} method, with some
 presumptions such as that the sum of weithts is equal to 1 and usage of
 specific normalization method.

WSM as implemented in the MCDA package presumes the performance matrix has
 been normalized, but it is up to the user to do that manually by whatever
 method (s-)he chooses. Also weights do not need to be normalized, though
 from point of view of the result interpretation it makes sense if it is
 normalized.

SAW processes decision problem in 3 basix steps:

Step 1: prepare initial performance matrix (nust be numeric)

We are working with n criteria (i-index) and m alternatives (j-index)
 forming matrix R of performance of the altenratives in criteria.

We presume that:

\mjsdeqn{\sum_{i=1}^n w_i= 1}

We can force this requirement by normalizing numeric vector of weights by:

\mjsdeqn{w_i' = \frac{w_i}{\sum w_i}}

step 2: normalize performance matrix for cost criteria

\mjsdeqn{r_{ij}' = \frac{min_j r_{ij}}{r_{ij}}}

and for benefit criteria

\mjsdeqn{r_{ij}' = \frac{r_{ij}}{max_j r_{ij}}}

step 3: integrating values of the criteria and weights

\mjsdeqn{S_j = \sum_{i = 1}^n w_i r_{ij}'}

Considering the above, the implementation works as special case of
 \link{wsm} and extensively uses that function for computation
 purposes.
}
\examples{

## ------------------------------------------------
## Method `saw$new`
## ------------------------------------------------

alternatives <- c('BLR', 'BOM', 'DEL', 'MNL', 'HYD', 'GRU', 'DUB',
  'KRK', 'MAA', 'EZE')
criteria <- c('tlnt', 'stab', 'cost', 'infl', 'tm-zn', 'infr', "life")
M <- rbind(
  c(0.8181818, 0.1814159, 1.0000000, 0.1198582, 0, 0.6, 0.750),
  c(1.0000000, 0.1814159, 0.6666667, 0.1198582, 0, 0.6, 0.375),
  c(1.0000000, 0.1814159, 0.8333333, 0.1198582, 0, 0.6, 0.125),
  c(0.8181818, 0.0000000, 1.0000000, 0.3482143, 0, 0.6, 0.375),
  c(0.1818182, 0.1814159, 1.0000000, 0.1198582, 0, 0.2, 0.375),
  c(0.1818182, 0.1814159, 0.5000000, 0.1198582, 0, 0.2, 0.125),
  c(0.0000000, 1.0000000, 0.0000000, 0.5741667, 1, 1.0, 1.000),
  c(0.3636364, 0.7787611, 0.6666667, 1.0000000, 1, 0.0, 0.500),
  c(0.4545455, 0.1814159, 0.9166667, 0.1198582, 0, 0.4, 0.000),
  c(0.1818182, 0.6283186, 0.5833333, 0.0000000, 0, 0.4, 0.125)
)
rownames(M) <- alternatives
colnames(M) <- criteria
w = c(0.125, 0.2, 0.2, 0.2, 0.175, 0.05, 0.05)
t <- saw$new(M, w)
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{SAW}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm_orig}}{original (not normalized) performance matrix}

\item{\code{pm}}{normalized performance matrix}

\item{\code{w}}{vector of weights (there are no other limitations on weights)}

\item{\code{minmax}}{vector specifying optimalization direction for the
criteria. Values max/min are expected. If all criteria are optimalized
in same direction the vector can be replaced by single value. Max value
is default.}

\item{\code{result_table}}{has weighted performance matrix with added columns
to summ performance and extress this sum as a percentage of the best
alternative}

\item{\code{weighted_sum_prc}}{vector specifying how close the alternatives are
to the best aleternative (expresed as the percentage of best) sorted
descending (from best to worst)}

\item{\code{scoreM}}{results of the WSM presented as stacked bar chart. The
graph clearly shows contribution of the criteria to overall performance
of the alternative.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-saw-new}{\code{saw$new()}}
\item \href{#method-saw-compute}{\code{saw$compute()}}
\item \href{#method-saw-summary}{\code{saw$summary()}}
\item \href{#method-saw-clone}{\code{saw$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saw-new"></a>}}
\if{latex}{\out{\hypertarget{method-saw-new}{}}}
\subsection{Method \code{new()}}{
Public constructor for the class. Checks validity of input parameters
 and performs computation of of the model based on them.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{saw$new(pm, w, minmax = "max")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{normalized performance matrix}

\item{\code{w}}{vector of weights, summ of weights = 1}

\item{\code{minmax}}{minmax vector specifying optimalization direction for the
criteria. Values max/min are expected. If all criteria are optimalized
in same direction the vector can be replaced by single value. Max value
is default.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{alternatives <- c('BLR', 'BOM', 'DEL', 'MNL', 'HYD', 'GRU', 'DUB',
  'KRK', 'MAA', 'EZE')
criteria <- c('tlnt', 'stab', 'cost', 'infl', 'tm-zn', 'infr', "life")
M <- rbind(
  c(0.8181818, 0.1814159, 1.0000000, 0.1198582, 0, 0.6, 0.750),
  c(1.0000000, 0.1814159, 0.6666667, 0.1198582, 0, 0.6, 0.375),
  c(1.0000000, 0.1814159, 0.8333333, 0.1198582, 0, 0.6, 0.125),
  c(0.8181818, 0.0000000, 1.0000000, 0.3482143, 0, 0.6, 0.375),
  c(0.1818182, 0.1814159, 1.0000000, 0.1198582, 0, 0.2, 0.375),
  c(0.1818182, 0.1814159, 0.5000000, 0.1198582, 0, 0.2, 0.125),
  c(0.0000000, 1.0000000, 0.0000000, 0.5741667, 1, 1.0, 1.000),
  c(0.3636364, 0.7787611, 0.6666667, 1.0000000, 1, 0.0, 0.500),
  c(0.4545455, 0.1814159, 0.9166667, 0.1198582, 0, 0.4, 0.000),
  c(0.1818182, 0.6283186, 0.5833333, 0.0000000, 0, 0.4, 0.125)
)
rownames(M) <- alternatives
colnames(M) <- criteria
w = c(0.125, 0.2, 0.2, 0.2, 0.175, 0.05, 0.05)
t <- saw$new(M, w)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saw-compute"></a>}}
\if{latex}{\out{\hypertarget{method-saw-compute}{}}}
\subsection{Method \code{compute()}}{
performs computation of SAW model based on class properties. Usually
 is not run manually as constructor calls this method automatically.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{saw$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saw-summary"></a>}}
\if{latex}{\out{\hypertarget{method-saw-summary}{}}}
\subsection{Method \code{summary()}}{
prepares summary of the SAW method resutls and outputs them
 to the console.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{saw$summary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-saw-clone"></a>}}
\if{latex}{\out{\hypertarget{method-saw-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{saw$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
