% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sir.R
\name{sir}
\alias{sir}
\title{Superiority and inferiority ranking (SIR) method}
\description{
SIR stands for Superiority and inferiority ranking (SIR) method.The method
 is interesting as it is computationwise closely related to PROMETHEE and
 TOPSIS methods. Similarly to them it computes preference based on flows.

The flows are computed based on S and I (superiority and inferiority)
 matrixes. Based on transformation of preference P(A, A2) from natural units
 to 0-1 according to 6 function (in same way as PROMETHEE computes them). S
 and I matrixes are defined:

\mjsdeqn{S_j(A_i) = \sum_{k=1}^m P_j(A_i, A_k) = \sum_{k=1}^m f_j(g_j(A_i) - g_j(A_k))}

and

\mjsdeqn{I_j(A_i) = \sum_{k=1}^m P_j(A_k, A_i) = \sum_{k=1}^m f_j(g_j(A_k) - g_j(A_i))}

Where m is the number of alternatives, fj is transformed value using
 function d.

Results in S and I matrixes need to be agregated.The method supports two
 agregation methods SIR-SAW or SIR-TOPSIS.

For SIR-SAW:

\mjsdeqn{SFlow(A_i) = \sum_{j=1}^n w_jS_j(A_i)}

\mjsdeqn{IFlow(A_i) = \sum_{j=1}^n w_jI_j(A_i)}

SIR-TOPSIS on the other hand uses computation of ideal and antiideal
 solution and computes S- and I- flows from it. See TOPSIS documentation for
 details.

This approach is used separately for both S and I matrixes. For computation
 of ideal and anti-ideal solution min and max functions are switched.

Directly from these flow complete rankings can be derived, or simple
 aggregation of them as net flow (diference between S and I flows) and
 relative flow as a closeness to addition of the S and I flows.
}
\examples{

## ------------------------------------------------
## Method `sir$new`
## ------------------------------------------------

# Example from the book (see references)
PM <- rbind(
   c(8,7,2,1),
   c(5,3,7,5),
   c(7,5,6,4),
   c(9,9,7,3),
   c(11,10,3,7),
   c(6,9,5,4)
)
rownames(PM) <- c('Site 1', 'Site 2', 'Site 3', 'Site 4', 'Site 5',
 'Site 6')
colnames(PM) <- c('Investment costs (million EUR)',
                  'Employment needs (hundred employees)',
                  'Social impact (1-7)',
                  'Environmental impact (1-7)'
)
minmax <- 'max'
w <- c(0.4, 0.3, 0.1, 0.2)
shape <- c('linear', 'linear', 'linear', 'linear')
q <- c(1, 1, 1, 1)
p <- c(2,2,2,2)
s <- c(0,0,0,0)
result <- SIR(PM, w, shape, minmax, q, p, s, SAW = TRUE)
}
\references{
Papathanasiou, Jason, Ploskas, Nikolaos. Multiple Criteria Decision Aid
 Methods, Examples and Python Implementations. Springer, 173 p., ISBN
 978-3-319-91648-4.
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{SAW}
\keyword{SIR}
\keyword{SIR-SAW}
\keyword{SIR-TOPSIS}
\keyword{flow}
\keyword{inferiority}
\keyword{net}
\keyword{relative}
\keyword{superiority}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm_orig}}{original (not transformed) performance matrix of
alternatives in criteria}

\item{\code{pm}}{performance matrix of alternatives in criteria (all criteria
are maximized)}

\item{\code{pref_function}}{vector, specifies type of function used to compute
preferences. Need to be set for each criterion. Possible values are:
'default', 'U-shape', 'V-shape', 'level', 'linear', 'Gaussian'. Choice
of function type will decide on what type of threshold (if any) is
required for computation. Each criterion can use different preference
function.}

\item{\code{w}}{vector of weights}

\item{\code{minmax}}{direction (max or min) of criteria optimization}

\item{\code{i_threshold}}{vector of indifference thresholds}

\item{\code{p_threshold}}{vector of proference thresholds}

\item{\code{im_threshold}}{vector containing intermetiate thresholds for
criteria. only Gaussian type performance functions rewuire this type of
threshold. If prefference and indifference thresholds are present, the
PROMETHEE function will try to 'gues' intermediate threshold as value
right in the middle between these thresholds.}

\item{\code{SAW}}{implicit TRUE, if set TRUE will aggregate S and I matrixes
using SIR-SAW method, otherwise it will use SIR-TOPSIS.}

\item{\code{superiorityFlow}}{vector of the alternatives derived from S matrix}

\item{\code{inferiorityFlow}}{vector of the alternatives derived from I matrix}

\item{\code{rankSFlow}}{vector of alternatives with assigned ranks (is possible
to directly derive from superiorityFlow)}

\item{\code{rankIFlow}}{vector of alternatives with assigned ranks (is possible
to directly derive from inferiorityFlow)}

\item{\code{partialRanking}}{matrix providing partial order of alternatives
with P-prefered, I-indifferent and R-incomparable values}

\item{\code{netFlow}}{differencce between superiority and inferiority flows}

\item{\code{relativeFlow}}{expresses closeness to addition of the S and I flows}

\item{\code{flows}}{matrix with all types of flows in one place}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-sir-new}{\code{sir$new()}}
\item \href{#method-sir-compute}{\code{sir$compute()}}
\item \href{#method-sir-summary}{\code{sir$summary()}}
\item \href{#method-sir-sensitivity}{\code{sir$sensitivity()}}
\item \href{#method-sir-clone}{\code{sir$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sir-new"></a>}}
\if{latex}{\out{\hypertarget{method-sir-new}{}}}
\subsection{Method \code{new()}}{
public constructor allowing the user to construct SIR decision analysis
 problem and compute it using either SAW or TOPSIS approach.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sir$new(
  pm,
  w,
  d,
  minmax = "max",
  i_threshold = NULL,
  p_threshold = NULL,
  im_threshold = NULL,
  SAW = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{Matrix or data frame containing the performance table. Each
row corresponds to an alternative, and each column to a criterion. only
numeric values expercted. Rows and columns are expected to be named.}

\item{\code{w}}{vector containing the weights of the criteria. Values need to
\mjseqn{0 \le w_i \le 1, \sum w_i = 1}}

\item{\code{d}}{vector, specifies type of function used to compute preferences.
Need to be set for each criterion. Possible values are: 'default',
'U-shape', 'V-shape', 'level', 'linear', 'Gaussian'. Choice of function
type will decide on what type of threshold (if any) is required for
computation. Each criterion can use different preference function.}

\item{\code{minmax}}{value or vector of values 'min' or 'max' specifying
optimization direction for the criterium}

\item{\code{i_threshold}}{vector containing indifference threshods for
criteria. Not all types of performance functions require it. The
parameter must be used if there is at least one criterion, for which it
is required. Values for all other criteria should be 0 (and will not be
used during computations). Only 'U-shape', 'level', 'linear' functions
need this threshold.}

\item{\code{p_threshold}}{vector containing prefference threshods for criteria.
Not all types of performance functions require it. The parameter must
be used if there is at least one criterion, for which it is required.
Values for all other criteria should be 0 (and will not be used during
computations). Only 'V-shape', 'level', 'linear' functions need this
threshold.}

\item{\code{im_threshold}}{vector containing intermetiate thresholds for
criteria. only Gaussian type performance functions rewuire this type of
threshold. If prefference and indifference thresholds are present, the
PROMETHEE function will try to 'gues' intermediate threshold as value
right in the middle between these thresholds.}

\item{\code{SAW}}{implicit TRUE, if set TRUE will aggregate S and I matrixes
using SIR-SAW method, otherwise it will use SIR-TOPSIS.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
initialized R6 class with computed results for SIR
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Example from the book (see references)
PM <- rbind(
   c(8,7,2,1),
   c(5,3,7,5),
   c(7,5,6,4),
   c(9,9,7,3),
   c(11,10,3,7),
   c(6,9,5,4)
)
rownames(PM) <- c('Site 1', 'Site 2', 'Site 3', 'Site 4', 'Site 5',
 'Site 6')
colnames(PM) <- c('Investment costs (million EUR)',
                  'Employment needs (hundred employees)',
                  'Social impact (1-7)',
                  'Environmental impact (1-7)'
)
minmax <- 'max'
w <- c(0.4, 0.3, 0.1, 0.2)
shape <- c('linear', 'linear', 'linear', 'linear')
q <- c(1, 1, 1, 1)
p <- c(2,2,2,2)
s <- c(0,0,0,0)
result <- SIR(PM, w, shape, minmax, q, p, s, SAW = TRUE)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sir-compute"></a>}}
\if{latex}{\out{\hypertarget{method-sir-compute}{}}}
\subsection{Method \code{compute()}}{
Computes SIR model based on parametrs specified in constructor.
 Normally this methods does not need to be run manually as constructor
 calls it automatically.

Manual re-computation si required only if the user changes class' fields
 without using the constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sir$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sir-summary"></a>}}
\if{latex}{\out{\hypertarget{method-sir-summary}{}}}
\subsection{Method \code{summary()}}{
summary of the SIR method resutls.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sir$summary()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
basic information on the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sir-sensitivity"></a>}}
\if{latex}{\out{\hypertarget{method-sir-sensitivity}{}}}
\subsection{Method \code{sensitivity()}}{
test sensitivity of the model to changes in the thresholds.

Provides sens_i (for indifference threshold), sens_p (for prefference
 threshold) and sens_im (for intermediate treshold) dataframes in
 structure:

\itemize{
  \item criterium
  \item from - lower bound of sensitivity
  \item default - value computed by original model
  \item to - upper bound of sensitivity
  \item function - type of preference function for criterium
}

Dataframes do have a numeric value with lower/upper bound of
 sensitivity identifying last value of the threshold for which the
 result still doesn't change.

If no such value is identified "insens." is provided.

Also note that PROMETHEE function is complex, because of existence of
 "preference" functions, which are stated separately for each criterium
 and each of these has a different requirements on types of thresholds
 it uses. For example level and linear functions use both preference and
 indifference thresholds (but not intermediate). V-shape function uses
 prefference threshold only, U-shape uses indifference threshold only.

PROMETHEE function is being utilized only in SIR-TOPSIS, so if SIR-SAW
 procedure is used the function only sneds an error message to terminal.

Gaussian function uses intermediate threshold only, but if preference
 andindifference thresholds are provided, the sensitivity is being
 tested on in interval between these two.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sir$sensitivity(step = 100)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{number of steps to divide threshold testing interval
(default: 100)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
dataframes sens_i, sens_p and sens_im with sensitivity limit for
 the criteria
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sir-clone"></a>}}
\if{latex}{\out{\hypertarget{method-sir-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sir$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
