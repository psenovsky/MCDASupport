% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pamssem.R
\name{pamssem}
\alias{pamssem}
\title{PAMSSEM}
\description{
Introduced by Martel, Kiss and Rousseau in 1996. The method uses concordance
 and discordance matrices like ELECTRE family of methods and measures of
 flows similar to PROMETHEE family of methods. Both ELECTRE and PROMETHEE
 also use concept of indifference (q), preference (p) and veto (v)
 thresholds the PAMSSEM utilizes also.

Method starts with local outranking index. For ordinal attributes we do that
 by

\mjsdeqn{\delta(A_i, A_j) = \sum_{A_j} \sum_{A_i} d_j(A_i, A_j)}

Please note that original implementation also works with probability
distributions fj(Ai) and fj(Aj) which usually are assumed equal to 1. This
implementation doesn't support these two function.

\mjsdeqn{d_j(A_i, A_j) = \left\lbrace\begin{array}{ll} 0 & \;if\; \Delta_j \le -p_j \cr \frac{\Delta_j - p_j}{p_j - q_j} & \;if\; -p_j < \Delta_j - q_j \cr 1 & \;if\; \Delta_j \ge -q_i \end{array}\right.} 

\mjsdeqn{\Delta_j = k_j(A_i) - k_j(A_j)}

where kj(A) is performance of alternative in crtierium i.

For cardinal attributes the computation is:

\mjsdeqn{d_j(A_i, A_j) = \left\lbrace\begin{array}{ll} 0 & \;if\; \Delta_j \le -1 \cr 0.5 & \;if\; -1 \le \Delta_j < 0 \cr 1 & \;if\; \Delta_j \ge 0 \end{array}\right.}

Delta j represent deffirence between the levels in this case.

Next concordance index is computed

\mjsdeqn{C(A_i, A_j) = \sum_{j = 1}^n \delta_j (A_i, A_j) \cdot w_j}

Local discoredance index is computed

\mjsdeqn{D(A_i, A_j) = \sum_{A_i} \sum_{A_j} \overline{D_j}(A_i, A_j)}

for ordinal attributes

\mjsdeqn{\overline{D_j}(A_i, A_j) = \left\lbrace\begin{array}{ll} 1 & \;if\; \Delta_j \le -v_j \cr - \frac{\Delta_j + p_j}{v_j - p_j} & \;if\; -v_j < \Delta_j < -p_j \cr 0 & \;if\; \Delta_j \ge -p_j \end{array}\right.}

for cardinal attributes

\mjsdeqn{\overline{D_j}(A_i, A_j) = \left\lbrace\begin{array}{ll} min(1, \xi(w_j)\Delta_j + \frac{\gamma_j + 1}{2} & \;if\; \Delta_j < -\frac{\gamma_j + 1}{2} \cr 0 & \;if\; \Delta_j \ge -\frac{\gamma_j + 1}{2} \end{array}\right.}

where gamma is the number of measurement scale levels in the used scale for
 the j-th criterium.

\mjsdeqn{\xi(A_i, A_j) = 0.2 (1 + \frac{w_j}{2})}

Outranking degree

\mjsdeqn{\varphi(A_i, A_j) = C(A_i, A_j) \cdot \prod_{j = 1}^n 1 - D_j^3(A_i, A_j)}

Finally from outranking degree we compute the flows. Entering flow:

\mjsdeqn{\varphi^+(A_i) = \sum_{A_i \in A} \varphi(A_i, A_j)}

loaving flow

\mjsdeqn{\varphi^-(A_i) = \sum_{A_i \in A} \varphi(A_j, A_i)}

and the net flow

\mjsdeqn{\varphi(A_i) = \varphi^+(A_i) - \varphi^-(A_i)}

Values of net flow are directly usable for ranking purposes ordered from
 highest to lowest. This is the approach PAMSSEM II method uses for ranking.

PAMSSEM I provides only partial ranking with following rules for proving that
 Ai is preffered to Aj.

\mjsdeqn{A_j \;P\; A_j \;if\; \left\lbrace\begin{array}{l} A_i \;P^+\; A_j \;and\; A_i \;P^-\; A_j \cr A_i \;P^+\; A_j \;and\; A_i \;I^-\; A_j \cr A_i \;I^+\; A_j \;and\; A_i \;P^-\; A_j \end{array}\right.}

We can say that Ai is indifferent to Aj if Ai I Aj and Aj I Ai.

Plese note that while support for PAMSSEM I is coded in the results are not
 validated and thus the implementation may include some errors.
}
\examples{

## ------------------------------------------------
## Method `pamssem$new`
## ------------------------------------------------

alt <- c("A1", "A2", "A3")
cri <- c("C1", "C2", "C3")
pm <- rbind(
  c(80, 90, 5),
  c(65, 58, 2),
  c(83, 60, 7)
)
rownames(pm) <- alt
colnames(pm) <- cri
w <- c(1, 1, 1) # weights equal
minmax <- c("min", "max", "max")
type <- c("C", "C", "O")
q <- c(5, 15, 1)
p <- c(12, 25, 2)
v <- c(18, 32, 3)
scale_level <- c(3, 3, 3)
t <- pamssem$new(pm, w, minmax, type, q, p, v)
}
\references{
Alinezhad, A., Khalili, J. New Methods and Applications in Multiple
 Attribute Decision Making (MADM). Springer Nature Switzerland AG, 2019,
 233 p., ISBN 978-3-030-15009-9
}
\author{
Pavel Šenovský \email{pavel.senovsky@vsb.cz}
}
\keyword{PAMSSEM}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{pm_orig}}{original performance matrix (as used in constructor)}

\item{\code{pm}}{performance matrix with all criteria converted to maximize}

\item{\code{w}}{weights vector}

\item{\code{minmax}}{vector of min/max (set direction of optimization for
criteria)}

\item{\code{type}}{vector of the types of the critera used, either "C" -
cardinal, or "O" - ordinal.}

\item{\code{q}}{vector of indifference thresholds}

\item{\code{p}}{vector of prefference thresholds}

\item{\code{v}}{vector of veto thresholds}

\item{\code{flows}}{data frame of flows}

\item{\code{pamssem_ii}}{ranking based on net flow (PAMSSEM II method)}

\item{\code{pamssem_i}}{final ranking using PAMSSEM I method (not
validated)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-pamssem-new}{\code{pamssem$new()}}
\item \href{#method-pamssem-compute}{\code{pamssem$compute()}}
\item \href{#method-pamssem-summary}{\code{pamssem$summary()}}
\item \href{#method-pamssem-clone}{\code{pamssem$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pamssem-new"></a>}}
\if{latex}{\out{\hypertarget{method-pamssem-new}{}}}
\subsection{Method \code{new()}}{
Public constructor. Valides the inputs and computes the method based on
 them.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pamssem$new(pm, w, minmax = "max", type, q, p, v)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pm}}{performance matrix. Criteria (in columns) are expected to be
ordered from most influential to least influential.}

\item{\code{w}}{weights vector}

\item{\code{minmax}}{vector of min/max (set direction of optimization for
criteria)}

\item{\code{type}}{vector of the types of the critera used, either "C" -
cardinal, or "O" - ordinal.}

\item{\code{q}}{vector of indifference thresholds}

\item{\code{p}}{vector of prefference thresholds}

\item{\code{v}}{vector of veto thresholds}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{alt <- c("A1", "A2", "A3")
cri <- c("C1", "C2", "C3")
pm <- rbind(
  c(80, 90, 5),
  c(65, 58, 2),
  c(83, 60, 7)
)
rownames(pm) <- alt
colnames(pm) <- cri
w <- c(1, 1, 1) # weights equal
minmax <- c("min", "max", "max")
type <- c("C", "C", "O")
q <- c(5, 15, 1)
p <- c(12, 25, 2)
v <- c(18, 32, 3)
scale_level <- c(3, 3, 3)
t <- pamssem$new(pm, w, minmax, type, q, p, v)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pamssem-compute"></a>}}
\if{latex}{\out{\hypertarget{method-pamssem-compute}{}}}
\subsection{Method \code{compute()}}{
computes ORESTE model based on parameters of the fields of the class.
 Usually run automatically as part of class inititation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pamssem$compute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pamssem-summary"></a>}}
\if{latex}{\out{\hypertarget{method-pamssem-summary}{}}}
\subsection{Method \code{summary()}}{
prepares summary of the PAMSSEM method resutls and outputs them
 to the console.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pamssem$summary()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pamssem-clone"></a>}}
\if{latex}{\out{\hypertarget{method-pamssem-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{pamssem$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
