---
title: "ELECTRE-teplate"
author: "Pavel Šenovský"
date: '2022-09-20'
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

# Úvod

Tato šablona už řeší pouze aplikaci metody. Pokud potřebujete podrobnější komentář k R, R markdown podívejte se do šablony pro metodu vážených součtů, která obsahuje také tyto informace

# ELECTRE I and II

Tato šablona demonstruje použití metod ELECTRE I a II.TEchnicky je tata šablona odvozeninou z WSM šablony, ale jsou do ní přidána také analýza citlivosti, kterou knihovna MCDASupport podporuje pro metodu ELECTRE II.

Vzhledem ke způsobu napsání proto doporučuji nejprve projít WSM šablonu a pochopit její fungování a teprve následně se vrátit k ELECTRE II (této šabloně).

```{r prepare the environment, include=FALSE}
packages <- c("mathjaxr", "graphics", "igraph", "diagram", "stats", "dplyr", "visNetwork", "plotly", "tidyr")
install.packages(setdiff(packages, rownames(installed.packages())))  
if(length(setdiff(c("MCDASupport"), rownames(installed.packages()))) == 1){
  # zkuste https://fbiweb.vsb.cz/~sen76 najít aktualizovanou knihovnu, pokud následující odkaz nefunguje
  url <- 'https://fbiweb.vsb.cz/~sen76/data/uploads/programy/MCDASupport_0.26.tar.gz'
  destfile <- paste(getwd(), '/MCDASupport_0.26.tar.gz')
  download.file(url, destfile)
  install.packages("MCDASupport_0.26.tar.gz", repos=NULL, type="source")  
}
library(MCDASupport) # activate the package
library(tidyr)
```

# ELECTRE I

Nejprve nadefinujeme problém - opět výběr čtečky, stejný příklad jako pro WSM (+ přednáška a skripta). V případě ELECTRE metod ale máme jednu výhodu. Hodnoty není potřeba normalizovat.

Transformace, kterou jsme dělali v rámci WSM mohou ale i v tomto případě představovat určitou výhodu. V takovém případě můžete normalizovat a znovu škálovat, nebo jenom škálovat (bez normalizace).

```{r performance matrix}
# define decision problem
PM <- as.data.frame(cbind(
  c(80, 80, 100, 80, 80),
  c(185, 200, 206, 198, 180),
  c(50, 100, 50, 100, 100),
  c(100, 20, 100, 100, 100),
  c(2100, 1700, 1700, 1700, 1900),
  c(3400, 3800, 3300, 3400, 4200)
))
colnames(PM) <- c('display', 'váha', 'tlačítka', 'front light', 'baterie', 'cena')
rownames(PM) <- c('Kobo Glo', 'Sony PRS-T3', 'Kindle Paperwhite 2', 
                  'Pocketbook Touch Lux', 'Bookeen Odyssey HD FL')
w <- c(5, 2, 4, 5, 3, 1)
w <- w/sum(w) # sum of w = 1
minmax <- c('max', 'min', 'max', 'max', 'max', 'min')
kable(PM, caption = 'Výkon alternativ v naturálních jednotkách')
```

```{r ELECTRE I results}
E_I <- Electre_1(PM, w, minmaxcriteria = minmax)
E_I$GraphResult
kable(E_I$Kernel, caption = 'Kernel řešení')
E_I$Dominated
```

# ELECTRE II

ELECTRE I poskytuje pouze kernel řešení, ale neposkytuje pořadí. Jelikož naším cílem je vybrat nejlepší čtečku, pořadí potřebujeme. Výpočet proto musí pokračovat pomocí ELECTRE II.

```{r ELECTRE II results}
E_II <- Electre_2(PM, w, minmax)
E_II$finalPreorderSorted
E_II$graphResult
```

Výše uvedený výsledek je dosažen s použitím předvolených hodnot jednotlivých hranic (threshold). Tyto hodnoty jsou c_minus = 0.65, c_zero = 0.75, c_plus = 0.85, d_minus = 0.25 a d_plus = 0.5. Pro správné nastavení těchto hranic není žádný pevně stanovený postup. Jednotlivé hranice nám slouží jako fuzzy čísla. Umožňují nám tak při srovnání rozhodnout, zda-li dve různé hodnoty alternativ v kritérií jsou skutečně dostatečně velké, aby bylo možné říci, že jedna varianta je lepší než druhá.

Tyto hranice tedy představují určitou nejistotu, kterou v našich datech máme. V případě, že jsou data kvalitní, pak jednotlivé rozsahy hranic mohou být "užší". Metoda pak bude lépe rozlišovat mezi variantami.

Můžeme to zkusit:

```{r ELECTRE II thresholds c up and d down}
E_II <- Electre_2(PM, w, minmax, c_minus = 0.8, c_zero = 0.88, c_plus = 0.95, 
                  d_minus = 0.1, d_plus = 0.25)
E_II$finalPreorderSorted
E_II$graphResult
```

Z hlediska emetody jsou ale jednotlivé varianty stejně příliš blízko u sebe a tak nám doporučuje Kobo Glo, Kindle Paperwhite 2 a Pocketbook Touch Lux, nezi kterými není schopna (při těchto nastavení hranic) rozlišit.

Existuje několik řešení této situace:

- můžeme se s ní smířit
- můžeme doplnit další informace do zadání problémů (reškálovat podobně jako u WSM, viz WSM template CZ)
- zlepšit odhad váhových koeficientů (např. metodou AHP)
- vyzkoušet odlišné nastavení koeficientů hranic

Právě poslední možnost budeme demonstrovat v této šabloně.

# Analýza citlivosti

ELECTRE II je z pohledu požadovaných vstupních parametrů zároveň jednodušší i složitější. Jednodušší je v tom, že nepožaduje normalizaci vstupů a jejich reškálování, složitější je v tom, že požaduje některé parametry navíc. Konkrétně se jedná o hranice (threshold) c0, c+, c-, d- a d+. Právě u techto parametrů může nastat problém s jejich správným nastavením.

Řešením tohoto problému je realizace analýzy citlivosti řešení na změny v těchto parametrech. MCDASupport knihovna poskytuje v současnosti tuto funkcionalitu v omezené míře pro metody ELECTRE II a III.

Pro ELECTRE II analýza citlivosti vyžaduje specifikaci rozsahů jednotlivých hranic, které následně budou otestovány a výsledek simulace bude vizualizován graficky. Oproti základní metodě ELECTRE II mají ale hranice odlišnou formu. Zatímco v základní metodě měly formát desetinného čísla v intervalu \<0;\1>, v případě funkce analýzy citlivosti mají formu čtyř prvkového vektoru (každý prvek vektoru v intervalu \<0;1\>), kde jednotlivé prvky mají následující význam:

- od, 
- do, 
- krok, 
- předvolená hodnota

Funkce má nastaveny následující základní parametry, které můžete použít jako výchozí bod analýzy, nebo je upravit podle potřeb.

Poznámka - předvolená hodnota by měla výt někde uprostřed zkoumaného intervalu možných hodnot hranice. 

```
c_minus = c(0.51, 0.74, 0.01, 0.65),
c_zero = c(0.66, 0.84, 0.01, 0.75),
c_plus = c(0.76, 0.99, 0.01, 0.85),
d_minus = c(0.01, 0.49, 0.01, 0.25),
d_plus = c(0.26, 0.66, 0.01, 0.5))
```
Analýza citlivosti funguje tak, že vytvoří vektory hodnot v intervalu od - do po kroku. V případě c_minus výše se tak bude jednat o 14-ti prvkový vektor. Tyto hodnoty se budou postupně aplikovat pro výpočet výsledku. Použije se přitom hodnota z vektoru měněné hranice a prodvolené hodnoty ostattních hranic. 

Analýzy citlivosti vždy mění pouze jeden parametr, tak abychom mohli zkoumat jak se projeví jeho změny na výsledku analýzy. Výsledkem proto bude v případě ELECTRE II 5 grafů reprezentující zněmy v jednotlivých hranicích.

To je do jisté míry omezující, protože z pohledu praktického řešení není řečeno, že bychom ve finále neměli měnit parametrů více. I takové analýzy jsou možné, ale MCDASupport knihovna je v současnosti přímo nepodporuje. 

Uvědomme si, že výše uvedené parametry povedou k velkému množství modelů c_minus = 14, c_zero = 18, c_plus = 23, d_minus = 49, d_plus = 40, což je celkem 144 modelů. To není úplně zanedbatelné číslo. V případě, že ale chceme spočítat všechny možné změny pak: 14 * 18 * 23 * 49 * 40 = 11 360 160 modelů. Electre II je relativně jednoduchá metoda, ale tento počet už zabere nějakou dobu pravděpodobně mude potřeba řešit i některé otázky využití paměti.

K výše uvedenému je potřeba také dodat, že uživatel na základě takových výpočtů nedostává informaci o tom, který z daných výsledků je správný. Může ale lépe pochopit, jak se analyzovaný problém chová a to může být při nastavování parametrů finálního modelu.

```{r ELECTRE II sensitivity analysis}
t <- Electre_2_sensitivity(PM, w,
      minmaxcriteria = minmax,
      c_minus = c(0.75, 0.85, 0.01, 0.8),
      c_zero = c(0.85, 0.91, 0.01, 0.88),
      c_plus = c(0.9, 0.99, 0.01, 0.95),
      d_minus = c(0.01, 0.15, 0.01, 0.1),
      d_plus = c(0.15, 0.35, 0.01, 0.25))
kable(t$c_minus_sensitivity, label = 'Citlivost změn c-')
kable(t$c_zero_sensitivity, label = 'Citlivost změn c0')
kable(t$c_plus_sensitivity, label = 'Citlivost změn c+')
kable(t$d_minus_sensitivity, label = 'Citlivost změn d-')
kable(t$d_plus_sensitivity, label = 'Citlivost změn d+')
t$c_minus_graph
t$c_zero_graph
t$c_plus_graph
t$d_minus_graph
t$d_plus_graph
```

Jak je patrné z výsledků výše, náš problém je zcela necitlivý ke změnám parametrů ... to nění úplně obvyklé. Může to být způsobeno celkouvou značnou podobností nabízených řešení analyzovaného problému.
